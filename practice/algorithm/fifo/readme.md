## FIFO

生产者跟消费者模式的实现方案
* 实现 Sync.Cond 版本
* 实现 channel 版本

### 生产者跟消费者模式与队列的区别联系
* 生产者消费者模式是一种并发设计模式，它描述了一个或多个生产者线程向一个共享的队列中放入对象，然后一个或多个消费者线程从队列中取出对象并执行它们12。这种模式可以将生产和消费的逻辑分离，并提供同步和缓冲的机制。
* 队列是一种数据结构，它遵循先进先出（FIFO）的原则，即最先放入队列的元素最先被取出3。队列可以用来实现生产者消费者模式，也可以用来实现其他场景，例如广度优先搜索（BFS）等。
* 生产者消费者模式和队列的实现区别在于，前者关注的是如何在多线程环境下使用队列来传递数据或任务，并处理同步、阻塞、缓冲等问题；后者关注的是如何在单线程或多线程环境下使用队列来存储数据或任务，并保证其顺序和完整性。

### 有没有什么场景是只能用生产者消费者模式而不能用队列？
没有什么场景是只能用生产者消费者模式而不能用队列的，因为生产者消费者模式本身就是基于队列的一种设计模式。

### 更适合用队列的场景

* 当你需要在单线程环境下处理数据或任务时，你可以使用队列来存储它们，并按照先进先出的顺序进行处理。例如，你可以使用一个队列来实现一个待办事项列表，每次从队列头部取出一个事项，并完成它。
* 当你需要在多线程环境下实现广度优先搜索（BFS）算法时，你可以使用队列来存储待访问的节点，并按照层次顺序进行访问。例如，你可以使用一个队列来实现一个图的遍历算法，每次从队列头部取出一个节点，并将其相邻的未访问过的节点加入到队列尾部。

### 更适合生产者消费者的场景

* 当你需要在多线程环境下处理大量的数据或任务时，你可以使用生产者消费者模式来提高并发性能和吞吐量。例如，你可以让一个或多个生产者线程从数据库或网络中读取数据，并将其放入一个共享的队列中；然后让一个或多个消费者线程从队列中取出数据，并进行计算或存储等操作。
* 当你需要在不同的组件或系统之间传递数据或任务时，你可以使用生产者消费者模式来解耦它们。例如，你可以让一个组件或系统作为生产者，向一个消息队列（如 Kafka、RabbitMQ 等）发送数据或任务；然后让另一个组件或系统作为消费者，从消息队列接收数据或任务，并进行处理。